1. 一个场景：

用户修改密码，或者一些基本信息改变之后，希望用户登陆失效，重新登陆。


技术点：

基于cookie的身份认证，cookie是由前端浏览器传递到后端的，前端无法知道用户什么时候发生改变，也无法即时让cookie失效。

解决方法：

用户表中增加一个字段，记录用户信息最后修改时间

扩展用户认证，比较cookie中保持的最后修改时间，和数据库中的时间是否不同

可通过认证cookie认证方案中的依赖注入配置参数来实现,CookieAuthenticationOptions.Events提供了扩展的可能。


2. 用户信息加密之后的字符串太长，怎么缩短cookie的长度？

解决方法：

将用户票据加密生成的字符串，存在服务端缓存中，将一个与之对应的GUID，通过cookie进行传递，认证解析时，再通过GUID从缓存中拿到
票据，将票据还原成用户主体。

以上实现，需要重写回话存储机制。可以通过实现ITicketStore接口，配置CookieAuthenticationOptions参数中的SessionStore实现。